---
layout: page.webc
title: Archive
---

<script webc:setup>
    const slugify = str => str.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '')

    const tags = Object.keys(collections)
        .filter(t => !['all', 'posts', 'danceEvents'].includes(t))
        .sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()))
        .map(t => ({
            name: t,
            count: collections[t].length,
            url: `/tags/${slugify(t)}/`,
        }))

    const posts = collections.posts
        // Quirk: Trying to merge p with p.data completely like so:
        //
        //     .map(p => ({ ...p, ...p.data, date: new Date(p.date) }))
        //
        // causes first build to fail for some reason. Instead, we do a
        // more targeted merge, but specifying the attributes we need to
        // copy.
        .map(p => ({ ...p.data, url: p.url, date: new Date(p.date) }))
        .sort((a, b) => b.date - a.date)
</script>

<h2>Tags</h2>
<ul class="archive-list archive-list--tags">
    <li class="archive-list__item" webc:for="(_, tag) in tags">
        <a class="archive-list__item-link" :href="tag.url">
            <span @raw="tag.name"></span>
            <span @raw="`${tag.count} post${pluralize(tag.count)}`"></span>
        </a>
    </li>
</ul>

<h2>Posts</h2>
<!---
Quirk: WebC docs claim that webc:for works with any iterable, but it throws an error
when I don't cast this Set to an array.
--->
<div webc:for="year of Array.from(new Set(posts.map(p => p.date.getFullYear())))">
    <h3 @raw="year"></h3>
    <blog-post-list-compact :@posts="posts.filter(p => p.date.getFullYear() === year)"></blog-post-list-compact>
</div>
